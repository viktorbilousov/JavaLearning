# Рекурсивные методы (Recursion)

Цель: Научиться создавать и вызывать методы для структурирования кода.
* пример рекурсия (вывод точек) 

Рекурсия — это метод, который вызывает сам себя для решения подзадачи.

## Пример: Сумма цифр числа

Этот метод рекурсивно вычисляет сумму цифр числа, например, для 1234 сумма цифр 1 + 2 + 3 + 4 = 10.

```java
public class RecursionExample {
    public static int sumOfDigits(int n) {
        if (n == 0) {
            return 0; // Базовый случай
        }
        return (n % 10) + sumOfDigits(n / 10); // Рекурсивный вызов
    }

    public static void main(String[] args) {
        System.out.println("Сумма цифр 1234: " + sumOfDigits(1234));
    }
}
```
✅ Выведет:

```text
Сумма цифр 1234: 10
```
## Как это работает?
```text
sumOfDigits(1234) → (4) + sumOfDigits(123)
sumOfDigits(123)  → (3) + sumOfDigits(12)
sumOfDigits(12)   → (2) + sumOfDigits(1)
sumOfDigits(1)    → (1) + sumOfDigits(0)
sumOfDigits(0)    → 0 (Базовый случай)
```
> Важно! Рекурсия должна всегда иметь базовый случай, иначе вызовы станут бесконечными.

## Хвостовая рекурсия (Tail Recursion)
   Рекурсию можно оптимизировать, если рекурсивный вызов идет последним.

Пример: Хвостовая рекурсия для вычисления факториала
```java
public class TailRecursionExample {
  public static int sumOfDigitsTail(int n, int acc) {
    if (n == 0) {
      return acc;
    }
    return sumOfDigitsTail(n / 10, acc + (n % 10)); // Хвостовая рекурсия
  }

  public static int sumOfDigits(int n) {
    return sumOfDigitsTail(n, 0);
  }

  public static void main(String[] args) {
    System.out.println("Сумма цифр 5678: " + sumOfDigits(5678));
  }
}
```
✅ Выведет:

```text
Сумма цифр 5678: 26
```

## Итеративная vs рекурсивная функция

```java
public class IterativeExample {
    public static int sumOfDigitsIterative(int n) {
        int sum = 0;
        while (n != 0) {
            sum += n % 10; // Добавляем последнюю цифру
            n /= 10; // Убираем последнюю цифру
        }
        return sum;
    }

    public static void main(String[] args) {
        System.out.println("Сумма цифр 5678 (итеративно): " + sumOfDigitsIterative(5678));
    }
}
```

Вывод
```text
Сумма цифр 5678 (итеративно): 26
```


 
### Сравнение рекурсивного и итеративного подходов

| Критерий             | Рекурсивный метод                      | Итеративный метод                    |
|----------------------|--------------------------------------|--------------------------------------|
| **Простота кода**    | Код более читаемый и компактный      | Код может быть длиннее и сложнее    |
| **Производительность** | Медленнее из-за накладных расходов на вызовы функций | Быстрее, так как нет накладных расходов |
| **Использование памяти** | Использует стек вызовов (O(n) в худшем случае) | Использует фиксированное количество памяти (O(1)) |
| **Глубина рекурсии**  | Может привести к `StackOverflowError` при глубокой рекурсии | Безопасен даже для больших входных данных |
| **Оптимизация**      | Возможна хвостовая рекурсия, но не всегда эффективна | Оптимизируется компилятором и выполняется быстрее |
| **Применимость**     | Подходит для задач с естественной рекурсией (деревья, графы) | Предпочтителен для линейных вычислений (сумма, поиск и т. д.) |

> **Вывод:**  
> Итеративный подход **обычно быстрее и безопаснее**, но **рекурсивный код часто проще и логичнее** для задач, связанных с деревьями, графами и рекурсивными структурами данных.


# Задания


## Рекурсия
* Напишите рекурсивный метод factorial, который принимает int n и возвращает факториал числа n.
```text
 5! = 1*2*3*4*5
 0! = 1
 1! = 1
 7! = 1*2*3...*7
```

* Напишите рекурсивный метод fibonacci, который принимает число n и возвращает n-е число Фибоначчи.
* Напишите рекурсивный метод `sumArray`, который возвращает сумму всех чисел в массиве.
  * Если массив пустой, вернуть `0`
  * Суммируйте первый элемент с результатом вызова для оставшихся элементов.

```java
public static void main(String[] args) {
    int[] numbers = {1, 2, 3, 4, 5};
    System.out.println(sumArray(numbers)); // Вывод: 15
}
```